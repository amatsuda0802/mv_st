abst
### SMPL: スキン付きマルチパーソンリニアモデル

我々は、より正確な人間の体形状と姿勢依存の形状変動を学習したモデルを提案します。このモデルは、既存のグラフィックスパイプラインと互換性があります。提案する「スキン付きマルチパーソンリニアモデル（SMPL）」は、スキン付きの頂点ベースのモデルで、自然な人間のポーズにおけるさまざまな体形状を正確に表現します。

### モデルのパラメータ
モデルのパラメータは、安静ポーズのテンプレート、ブレンドウェイト、姿勢依存のブレンドシェイプ、アイデンティティ依存のブレンドシェイプ、頂点から関節位置への回帰器などのデータから学習されます。従来のモデルとは異なり、姿勢依存のブレンドシェイプは、ポーズ回転行列の要素の線形関数として定義されます。このシンプルな定式化により、異なるポーズの異なる人々の3Dメッシュを大規模に整列させたデータからモデル全体をトレーニングすることが可能になります。

### 定量的評価
SMPLのバリアントを線形またはデュアルクォータニオンブレンドスキニングを用いて定量的に評価した結果、いずれも同じデータでトレーニングされたBlendSCAPEモデルよりも精度が向上していることが示されました。

### 動的軟組織変形のモデリング
さらに、SMPLを拡張して現実的な動的軟組織の変形をモデル化しています。ブレンドスキニングに基づいているため、SMPLは既存のレンダリングエンジンと互換性があり、研究目的で利用可能です。





1 intro
### SMPL: スキン付きマルチパーソンリニアモデル

私たちの目標は、異なる体形状を表現でき、自然なポーズに合わせて変形し、実際の人間のように軟組織の動きを示す現実的なアニメーションされた人間の体を作成することです。このようなモデルは、レンダリングが高速で、展開が簡単で、既存のレンダリングエンジンと互換性があることを求めています。

### 従来のアプローチ
商業的なアプローチは、通常、メッシュを手動でリギングし、伝統的なスキニング手法の問題を修正するために手動でブレンドシェイプを彫刻することが含まれます。多くのブレンドシェイプが通常必要であり、それらを構築するための手動作業は膨大です。一方で、研究コミュニティは、さまざまなポーズの異なる体の例スキャンから統計的な体モデルを学習することに焦点を当てています。しかし、これらのアプローチは、標準的なスキニング手法を使用する既存のグラフィックスソフトウェアやレンダリングエンジンと互換性がありません。

### 目的
私たちの目的は、現実的でありながら既存のグラフィックスソフトウェアと互換性のある体モデルを自動的に学習することです。そのため、私たちは「スキン付きマルチパーソンリニア（SMPL）」モデルを提案します。このモデルは、広範な人間の体形状を現実的に表現でき、自然な姿勢依存の変形でポーズでき、軟組織のダイナミクスを示し、アニメーションが効率的で、既存のレンダリングエンジンと互換性があります（図1参照）。

### 従来の手法の問題点
従来の手法は、頂点が基盤となるスケルトン構造とどのように関連しているかをモデル化します。基本的なリニアブレンドスキニング（LBS）モデルは最も広く使用されており、すべてのゲームエンジンでサポートされ、レンダリングが効率的です。しかし、残念ながら、関節で不自然な変形を引き起こし、よく知られた「タフィー」や「ボウタイ」効果を生じさせます（図2参照）。これらの効果を軽減するためのスキニング手法に多大な努力が注がれてきました。さらに、データから非常に現実的な体モデルを学習するための研究も数多く行われています。これらの手法は、多くの人々の体形状やポーズによる非剛体変形を捉えることができます。しかし、既存のモデルは、リアリズムに欠ける、既存のパッケージと互換性がない、さまざまな体形状を表現できない、標準的なグラフィックスパイプラインと互換性がない、または多大な手作業が必要です。

### 目指すべきモデル
私たちのアプローチは、体モデルをできるだけシンプルで標準的に保つことを目指しており、同時にデータから学習した変形ベースのモデルのリアリズムを維持します。具体的には、標準的なスキニングの制限を修正するためのブレンドシェイプを学習します。アイデンティティ、ポーズ、軟組織ダイナミクスに対する異なるブレンドシェイプは、休止テンプレートと加算的に組み合わされ、ブレンドスキニングによって変換されます。私たちのアプローチの重要な要素は、ポーズブレンドシェイプを部分の回転行列の要素の線形関数として定式化することです。この定式化は、以前の手法とは異なり、ブレンドシェイプのトレーニングとアニメーションをシンプルにします。回転行列の要素は制約されているため、結果として生じる変形も制約され、モデルの一般化能力が向上します。

### SMPLモデルの学習と動的変形

私たちのアプローチでは、登録されたメッシュと私たちのモデル間の各頂点の差異をペナルティとして与える目的関数を採用しています。これにより、データからの学習が可能になります。ポーズによる変形を学習するために、さまざまなポーズの異なる被験者から得られた1786の高解像度3Dスキャンを使用します。テンプレートメッシュを各スキャンに整合させてトレーニングセットを作成し、ブレンドウエイト、ポーズ依存のブレンドシェイプ、平均テンプレート形状（休止ポーズ）、形状から関節位置を予測する回帰器を最適化して、トレーニングセットに対する頂点誤差を最小化します。この共同回帰器は、体形状に基づいて関節の位置を予測し、どんな体形状でも現実的なポーズ依存の変形をアニメーション化するために重要です。すべてのパラメータは、整合されたスキャンから自動的に推定されます。

### 体形状の学習
男性および女性の体形状のリニアモデルは、CAESARデータセットから学習します（約2000スキャン/性別）。各スキャンにテンプレートメッシュを登録し、データをポーズノーマライズします。これは、頂点ベースの形状モデルを学習する際に重要です。得られた主成分は、体形状のブレンドシェイプになります。SMPLモデルはさまざまな形式でトレーニングされ、同じデータでトレーニングされたBlendSCAPEモデルと定量的に比較されます。トレーニングに使用されなかったメッシュを使用して、モデルを質的にアニメーションで評価し、定量的に頂点誤差を比較します。SMPLの2つの主要なバリアント、すなわちリニアブレンドスキニング（LBS）を使用するものとデュアルクォータニオンブレンドスキニング（DQBS）を使用するものを探求します。驚くべきことに、SMPLのような頂点ベースのスキンモデルは、同じデータでトレーニングされたBlendSCAPEのような変形ベースのモデルよりも実際により正確です。テストメッシュは研究目的で利用可能であり、他の研究者がSMPLと定量的に比較できるようにしています。

### 動的変形の捕捉
SMPLモデルを拡張して軟組織ダイナミクスを捉えるために、Dynaモデルを適応させたDynamic-SMPL（DMPL）モデルを提案します。DMPLは、Dynaと同じ4Dメッシュデータセットからトレーニングされますが、三角形の変形ではなく頂点に基づいています。DMPLでは、SMPLとDynaのトレーニングメッシュ間の頂点誤差を計算し、休止ポーズに変換してPCAを使用して次元を削減し、動的なブレンドシェイプを生成します。次に、部位の角速度や加速度、動的変形の履歴に基づいて軟組織モデルをトレーニングします。軟組織の動態は体形状に大きく依存するため、異なる体重指数を持つ体を使用してDMPLをトレーニングし、体形状に依存する動的変形のモデルを学習します。標準のレンダリングエンジンでの軟組織の動態アニメーションは、ポーズのシーケンスから動的なリニアブレンドシェイプ係数を計算するだけで実行できます。DynaとDMPLのアニメーションを並べて比較すると、DMPLの方が現実的であることが明らかになります。このSMPLの拡張は、加算的ブレンドシェイプアプローチの汎用性を示し、変形が体形状に依存する方法を示し、体形状モデリングのための拡張可能な基盤を提供することを示しています。

### SMPLのアニメーション
SMPLモデルは、標準のレンダリングエンジンを使用してCPU上でリアルタイムよりもはるかに高速にアニメーション化できます。したがって、SMPLはこの分野のオープンな問題に対処し、現実的な学習モデルをアニメーターにアクセス可能にします。SMPLの基本テンプレートはアニメーションを考慮して設計されており、低ポリゴン数、シンプルな頂点トポロジー、クリーンな四角形構造、標準的なリグ、合理的な顔や手の詳細を持っています（ただし、ここでは手や顔をリグしていません）。SMPLは、アニメーションシステムにインポート可能なAutodesk Filmbox（FBX）ファイルとして表現できます。私たちはSMPLモデルを研究目的で利用可能にし、Maya、Blender、Unreal Engine、およびUnityでモデルを駆動するためのスクリプトを提供します。





2 related work
### アニメーション業界におけるスキニングとブレンドシェイプ

**リニアブレンドスキニングとブレンドシェイプ**は、アニメーション業界で広く使用されています。研究コミュニティは、品質の高い結果を生成する関節のある体形状の新しいモデルを提案してきましたが、これらは業界の実践と互換性がありません。多くの著者は、以下のように様々な成功を収めつつ、これらの世界を結びつけようと試みてきました。

### ブレンドスキニング
スケルトンサブスペース変形手法（ブレンドスキニングとも呼ばれる）は、メッシュの表面を基礎となるスケルトン構造に接続します。メッシュ表面の各頂点は、隣接する骨の重み付けされた影響を使用して変換されます。この影響は、リニアブレンドスキニング（LBS）のように線形に定義することができます。LBSの問題は広く発表されており、四元数やデュアル四元数スキニング、球面スキニングなど、これらの問題を修正しようとする一般的な手法が数多く文献に記載されています【Wang and Phillips 2002; Kavan and Zˇ ara 2005; Kavan et al. 2008; Le and Deng 2012; Wang et al. 2007】。しかし、一般的な手法はしばしば不自然な結果を生むため、ここでは特定の定式化に関係なく、ブレンドスキニングの制限を修正する学習に焦点を当てます。

### オートリギング
LBSモデルを自動的にリギングするための研究も多く行われており【De Aguiar et al. 2008; Baran and Popovic´ 2007; Corazza and Gambaretto 2014; Schaefer and Yuksel 2007】、商業的なソリューションも存在します。特に関連するのは、メッシュのコレクションから骨、関節、ブレンドウエイトを推測する手法です【Le and Deng 2014】。ただし、これらの手法はブレンドシェイプを修正することを学習しないため、LBSモデルの一般的な問題に対処していません。メッシュのシーケンスから生成されたモデルは、新しいポーズや動作にうまく一般化しない可能性があります。ここでは、運動学的構造が既知であると仮定していますが、上記の手法を使用してこれを学習するために拡張することも可能です。

### 制限と課題
上記の手法の主な制限は、モデルが体形状のスペースをカバーしていないことです。Millerらは、事前にリギングされたモデルのデータベースを使用して自動リギングを行うことでこれを部分的に解決しました。彼らは、既知のモデルから新しいモデルへのスキニングウエイトの転送と適応のプロセスとしてリギングとスキニングを定式化しています。彼らの手法はブレンドシェイプを生成せず、標準的なLBSのアーティファクトを生み出し、明確な目的関数を最小化しません。

### ブレンドシェイプのアプローチ
基本的なブレンドスキニングの欠点に対処するために、ポーズ空間変形モデル（PSD）【Lewis et al. 2000】は、基準形状に対する変形（頂点の変位）を定義します。これらの変形は、関節のポーズの関数です。この基本的な定式化は、後のアプローチによって広く踏襲されており、「散在データ補間」や「補正エンベローピング」とも呼ばれています【Rouet and Lewis 1999】。私たちは、ウェイテッドポーズスペース変形（WPSD）【Kurihara and Miyata 2004; Rhee et al. 2006】に似たアプローチを取ります。このアプローチでは、休止ポーズで修正を定義し、標準的なスキニング方程式（LBSなど）を適用します。具体的には、特定のキー ポーズのための修正シェイプ（スカルプト）を定義し、基準形状に追加してブレンドスキニングによって変換することで、正しい形状を生成します。

通常、サンプルポーズへの距離（ポーズ空間内）を見つけ、距離に基づいてサンプルを非線形に重み付けするための関数（例：ラジアルベース（RBF）カーネル）を使用します【Lewis et al. 2000】。スカルプトされたブレンドシェイプは重み付けされて線形に結合されます。これらのアプローチはすべて、サンプル形状への重み付き距離を計算することに基づいています。したがって、これらの手法では、修正ブレンドシェイプを取得するために距離と重みを実行時に計算する必要があります。特定のアニメーション（例：ビデオゲーム）では、これらの重みは事前にポーズに基づいて定義され、「ベイク」されてモデルに組み込まれます。ゲームエンジンは、ベイクされた重みをブレンドシェイプに適用します。スカルプト作業は通常アーティストによって行われ、アニメーションで使用されるポーズのためだけに行われます。

### ポーズモデルの学習

**Allen et al. (2002)**は、ポーズ空間変形（PSD）アプローチを利用し、手動で修正を行うのではなく、登録された3Dスキャンからそれらを学習します。彼らの研究は、全体の人間の体ではなく、個人の上半身と腕のモデリングに主に焦点を当てています。重要なポーズの変形を保存し、それらの間を補間します。保存された形状に近いとき、これらの手法は実質的に完璧ですが、新しいポーズに対しては一般化しにくく、密なトレーニングデータを必要とします。人間の関節の全範囲をモデル化するには、どれだけの形状が必要かは不明です。モデルの複雑性が増すにつれて、これらの形状をすべて制御し、相互作用させる複雑さも増します。

この問題を解決するために、**Kry et al. (2002)**は各関節の変形のために低次元の主成分分析（PCA）基底を学習します。ポーズ依存の変形は、基底ベクトルの係数で表現されます。**Kavan et al. (2009)**は、非線形スキニング手法を用いて生成された例メッシュを使用して線形近似を構築します。**James and Twigg (2005)**は、登録されたメッシュから直接骨（非剛性、アフィン骨）とスキニングウエイトを学習するというアイデアを組み合わせます。ブレンドシェイプに関しては、**Kry et al. (2002)**に類似したアプローチを使用します。

ブレンドスキニングの制限に対処するもう1つの方法は、「マルチウェイトエンベローピング（MWE）」です【Wang and Phillips 2002】。各頂点を骨の変換行列の重み付けされた組み合わせで重み付けするのではなく、MWEはこれらの行列の要素に対して重みを学習します。これにより、モデルの能力が増加します（パラメータが増える）。**James and Twigg (2005)**と同様に、彼らは骨の変換を過剰にパラメータ化して表現力を向上させ、PCAを使用して不要な自由度を除去します。彼らの実験は通常ユーザーの相互作用を伴い、MWEアプローチは現在のゲームエンジンではサポートされていません。

**Merry et al. (2006)**は、MWEが過剰にパラメータ化されていることを発見しました。なぜなら、それによって頂点がグローバル座標系における回転に応じて異なる変形を許すからです。彼らのアニメーションスペースモデルは、表現力をほとんど失うことなくパラメータ化を減らし、計算効率もLBSと同等であることを示します。**Mohr and Gleicher (2003)**は、例メッシュから効率的かつ現実的な線形モデルを学習する別のアプローチを提案します。しかし、LBSの問題に対処するために、筋肉の膨らみのような効果を捕えるために追加の「骨」を導入します。これらの追加の骨は複雑さを増し、物理的ではなく、アーティストには直感的ではありません。私たちのブレンドシェイプは、よりシンプルで直感的、実用的で、よりリアルな表現を提供します。同様に、**Wang et al. (2007)**は、表面変形に関連する関節を導入します。彼らの回転回帰アプローチは、変形勾配を使用し、これを頂点表現に変換する必要があります。

### ポーズと形状モデルの学習
上記の手法は、ポーズ可能な単一形状モデルの学習に焦点を当てています。しかし、私たちの目標は、人間の形状変動のスペースをカバーする現実的なポーズ可能なモデルを持つことです。初期の手法は、PCAを使用して人間の体形状のスペースを特性化します【Allen et al. 2003; Seo et al. 2003】が、体形状がポーズとどのように変化するかをモデル化していません。最も成功したモデルクラスは、**SCAPE**に基づいており【Anguelov et al. 2005】、体形状とポーズ依存の形状を三角形の変形という観点で表現します【Chen et al. 2013; Freifeld and Black 2012; Hasler et al. 2009; Hirshberg et al. 2012; Pons-Moll et al. 2015】。これらの手法は、異なる体形状とポーズを含むトレーニングスキャンから形状変動の統計モデルを学習します。三角形の変形は、体形状の変動、剛体部分の回転、ポーズ依存の変形など、さまざまな変換の合成を可能にします。

**Weber et al. (2007)**は、SCAPEの特性を持ちながら、これを例形状とブレンドさせるアプローチを提示します。しかし、これらのモデルは既存のアニメーションソフトウェアと整合性がありません。**Hasler et al. (2010)**は、ポーズ用と体形状用の2つのリニアブレンドリグを学習します。形状変化を表現するために、頂点の形状変化を制御する抽象的な「骨」を導入します。特定の形状のキャラクターをアニメーション化するには、形状とポーズの骨を操作します。彼らは基本メッシュとブレンドウエイトを学習しますが、ブレンドシェイプは学習しません。したがって、モデルはリアリズムに欠けます。

私たちが望むのは、三角形変形モデルの表現力を持つ頂点ベースのモデルであり、自然な形状とポーズの範囲を捕えることができるものです。**Allen et al. (2006)**は、そのようなモデルを定式化しています。特定の基本体形状に対して、彼らは散発的/サンプルPSDを使用してポーズ変形をモデル化する標準的なLBSモデルを定義します（RBFを使用）。彼らは、修正ブレンドシェイプを表現するための「キー角」を貪欲に定義し、すべての体形状でこれを固定します。特定の体形状は、休止ポーズの頂点、キー角における修正ブレンドシェイプ、骨の長さによってパラメータ化され、これらは「キャラクターベクター」を構成します。異なる体のための異なるキャラクターベクターを持つことで、彼らは新しい体形状に一般化できる低次元の潜在空間を学習します。これらのパラメータはデータから学習されます。彼らのモデルは、私たちのモデルよりも複雑で、パラメータが少なく、データもはるかに少なく学習されています。SMPLとの比較に関する詳細な分析は、セクション7で提示されます。





3 model formulation
### SMPLモデルの概要

私たちのスキン多人数線形モデル（SMPL）は、図3に示されています。SCAPEと同様に、SMPLモデルは体形状をアイデンティティ依存の形状と非剛体ポーズ依存の形状に分解しますが、SCAPEとは異なり、修正ブレンドシェイプを使用した頂点ベースのスキニングアプローチを採用しています。単一のブレンドシェイプは、連結された頂点オフセットのベクトルとして表現されます。最初に、アーティストが作成したメッシュがあり、これはN = 6890頂点とK = 23関節を持っています。このメッシュは、男性と女性で同じトポロジーを持ち、空間的に変化する解像度、クリーンな四角形構造、部品へのセグメンテーション、初期のブレンドウエイト、およびスケルトンリグを備えています。部品のセグメンテーションと初期のブレンドウエイトは図6に示されています。

標準的なスキニングの実践に従い、モデルは平均テンプレート形状によって定義され、これはゼロポーズにおけるN連結頂点のベクトルT¯ ∈ R³ⁿで表されます。また、ブレンドウエイトのセットW ∈ Rⁿ×ᴷ（図3(a)）と、ブレンドシェイプ関数BS(θ) : R|θ| → R³ⁿが含まれ、入力として形状パラメータのベクトルθを取り、出力として被験者のアイデンティティを彫刻するブレンドシェイプを生成します。さらに、K関節位置（図3(b)の白い点）を予測する関数J(θ) : R|θ| → R³ᵏもあり、これも形状パラメータに依存します。ポーズ依存のブレンドシェイプ関数BP(θ) : R|θ| → R³ⁿは、入力としてポーズパラメータのベクトルθを取り、ポーズ依存の変形の影響を考慮します（図3(c)）。これらの関数の修正ブレンドシェイプは、静止ポーズで合計され、図3(c)に示されています。最後に、標準的なブレンドスキニング関数W(·)（リニアまたはデュアルクォータニオン）が適用され、推定された関節中心の周りで頂点を回転させ、ブレンドウエイトによって定義されるスムージングが行われます。結果として、モデルM(θ, θ; λ) : R|θ| × |θ| → R³ⁿが生成され、形状とポーズのパラメータを頂点にマッピングします（図3(d)）。ここで、λは以下に説明する学習されたモデルパラメータを表します。

以下では、LBSおよびDQBSスキニング手法の両方を使用します。一般に、スキニング手法は一般的なブラックボックスと考えることができます。特定のスキニング手法が与えられた場合、私たちの目標は、学習したパラメータλを使用して、トレーニングメッシュをモデル化するために手法の制限を補正することです。学習されたポーズブレンドシェイプは、ブレンドスキニング関数によって引き起こされる誤りと、ポーズの変化による静的な軟部組織変形の両方を修正します。

以下では、モデル内の各項を説明します。便利のために、記法の概要が付録の表1に提供されています。

### ブレンドスキニングの概要

ブレンドスキニングのアイデアを固定し、記法を定義するために、LBS（Linear Blend Skinning）バージョンを提示します。このバージョンは説明が明確になるため、SMPLのDQBS（Dual Quaternion Blend Skinning）バージョンは、スキニング方程式を変更するだけで済みます。メッシュやブレンドシェイプは、太字の大文字（例：X）で表され、特定の頂点を表すベクトルは小文字の太字（例：xi ∈ R³）で表されます。頂点は、同次座標系で表されることがあります。標準の座標系と同次座標系のいずれかの形で、頂点がどのように表現されるかは文脈から明らかになるべきなので、同じ記法を使用します。

体のポーズは標準的なスケルトンリグによって定義されます。このリグでは、~!k ∈ R³が運動学ツリーにおける親に対する部分kの相対回転の軸-角表現を示します。私たちのリグにはK = 23の関節があり、ポーズ~✓は|~✓| = 3 × 23 + 3 = 72のパラメータで定義されます。これは、各部分に対して3、さらにルートの向きを示すための3が含まれています。!¯ = ~!k / k~!kを、回転の単位ノルム軸とします。次に、各関節jの軸角はロドリゲスの公式を使用して回転行列に変換されます。

\[
\text{exp}(\tilde{!}_j) = I + \tilde{!}_b j \sin(k~!_j k) + \tilde{!}_b^2 j \cos(k~!_j k) \tag{1}
\]

ここで、!b¯は3ベクトル!¯の斜対称行列で、Iは3×3の単位行列です。これを用いて、標準的なリニアブレンドスキニング関数W(T¯, J, ~✓, W) : R³ⁿ × R³ᴷ × |θ~| × |W| → R³ⁿは、静止ポーズにおける頂点T¯、関節位置J、ポーズ~✓、ブレンドウエイトWを入力として受け取り、ポーズ付きの頂点を返します。静止ポーズにおける各頂点¯tiは、次のように変換されます。

\[
\bar{t}^0_i = \sum_{k=1}^{K} w_{k,i} G^0_k(~✓, J) \bar{t}_i \tag{2}
\]

ここで、G^0_k(~✓, J)は、静止ポーズにおける変換を取り除いた後の同じ変換を表します。G_k(~✓, J)は関節kのワールド変換で、次のように定義されます。

\[
G_k(~✓, J) = \prod_{j \in A(k)} \begin{bmatrix}
\text{exp}(~!_j) & j_j \\
0 & 1
\end{bmatrix} \tag{4}
\]

ここで、wk,iはブレンドウエイト行列Wの要素であり、関節kの回転が頂点iにどのように影響するかを表します。exp(~!_j)は関節jに対応するローカル3×3回転行列であり、G_k(~✓, J)は関節kのワールド変換を示します。A(k)は、関節kの順序付きの親関節の集合を示します。既存のレンダリングエンジンとの互換性のため、Wは疎であり、頂点に最大4つの部分が影響を与えることを許可します。

多くの手法が式(2)を修正し、スキニングをより表現力豊かにしています。たとえば、MWE（Multi-Weight Enveloping）[Wang and Phillips 2002]は、G_k(~✓, J)をより一般的なアフィン変換行列に置き換え、スカラー重みを変換行列の各要素ごとに別々の重みに置き換えます。このような変更は表現力がありますが、既存のアニメーションシステムとは互換性がありません。

互換性を維持するために、基本的なスキニング関数を保持し、代わりにテンプレートを加算的に修正し、関節位置を予測する関数を学習します。私たちのモデルM(~, ~✓; λ)は次のように表されます。

\[
M(~, ~✓) = W(T_P(~, ~✓), J(~), ~✓, W) \tag{5}
\]

ここで、T_P(~, ~✓)は次のように定義されます。

\[
T_P(~, ~✓) = T¯ + BS(~) + BP(~✓) \tag{6}
\]

ここで、BS(~)とBP(~✓)は、テンプレートからのオフセットを表す頂点のベクトルです。それぞれ、形状ブレンドシェイプおよびポーズブレンドシェイプと呼びます。

この定義に従って、頂点¯tiは次のように変換されます。

\[
\bar{t}^0_i = \sum_{k=1}^{K} w_{k,i} G^0_k(~✓, J(~))(\bar{t}_i + b_S,i(~) + b_P,i(~✓)) \tag{7}
\]

ここで、b_S,i(~)およびb_P,i(~✓)はそれぞれBS(~)およびBP(~✓)の頂点であり、頂点¯tiに対する形状およびポーズのブレンドシェイプオフセットを表します。したがって、関節の中心は体形状の関数になり、ブレンドスキニングによって変形されるテンプレートメッシュは、ポーズと形状の両方の関数になっています。以下では、各項を詳細に説明します。

### 形状ブレンドシェイプとポーズブレンドシェイプ

#### 形状ブレンドシェイプ
異なる人々の体形状は、以下の線形関数で表現されます。

\[
BS(~; S) = \sum_{n=1}^{|~|} nS_n \tag{8}
\]

ここで、~ = [1, ..., |~|]^T、|~|は線形形状係数の数、Sn ∈ R³ⁿは形状変位の直交主成分を表します。すべての形状変位の行列はS = [S₁, ..., S₍|~|₎] ∈ R³ⁿ×|~|とし、登録されたトレーニングメッシュから学習されます（Sec. 4参照）。セミコロンの右側にある値は学習されたパラメータを表し、左側はアニメーターによって設定されるパラメータです。便宜上、トレーニング中に明示的に最適化されない場合、学習されたパラメータを省略することがよくあります。図3(b)は、これらの形状ブレンドシェイプをテンプレートT¯に適用して新しい体形状を生成する様子を示しています。

#### ポーズブレンドシェイプ
ポーズベクトル~✓を相対回転行列のベクトルにマッピングする関数R : R|θ~| → R⁹ᴷを定義します。このリグには23の関節があるため、R(~✓)は長さ(23 × 9 = 207)のベクトルです。R(~✓)の要素は、関節角度のサインおよびコサイン（式(1)）の関数であり、そのためR(~✓)は~✓に対して非線形です。

私たちの定式化は、ポーズブレンドシェイプの効果をR*（~✓） = (R(~✓) - R(~✓*))に対して線形であると定義する点で、従来の研究とは異なります。ここで、~✓*は静止ポーズを示します。R(~✓)のn番目の要素をRn(~✓)とすると、静止テンプレートからの頂点の変位は次のように表されます。

\[
BP(~✓; P) = \sum_{n=1}^{9K} (R_n(~✓) - R_n(~✓*))P_n \tag{9}
\]

ここで、ブレンドシェイプPn ∈ R³ⁿは頂点の変位のベクトルです。P = [P₁, ..., P₍⁹K₎] ∈ R³ⁿ×⁹ᴷはすべての207ポーズブレンドシェイプの行列です。このように、ポーズブレンドシェイプ関数BP(~✓; P)は、Sec. 4で学習される行列Pによって完全に定義されます。

静止ポーズ回転ベクトルR(~✓*)を引くことにより、ポーズブレンドシェイプの寄与が静止ポーズでゼロになることが保証され、これはアニメーションにとって重要です。

#### 関節の位置
異なる体形状は異なる関節位置を持ちます。各関節は、静止ポーズにおける3D位置で表現されます。これらが正確であることが重要であり、そうでないとスキニング方程式を使用してモデルをポーズする際にアーティファクトが生じる可能性があります。このため、関節を体形状~の関数として定義します。

\[
J(~; J, T¯, S) = J(T¯ + BS(~; S)) \tag{10}
\]

ここで、Jは静止頂点を静止関節に変換する行列です。私たちは、この回帰行列Jを、さまざまなポーズの異なる人々の例から学習します。これは、異なる体形状のメッシュ頂点がどのように重要であるか、そしてそれらをどのように組み合わせて関節位置を推定するかをモデル化しています。

### SMPLモデルの定義

SMPLモデルの完全なモデルパラメータのセットを次のように指定できます：

\[
\Theta = \{ \bar{T}, W, S, J, P \}
\]

これらのパラメータの学習方法についてはSec. 4で説明します。学習が完了したら、これらのパラメータは固定され、新しい体形状とポーズはそれぞれ形状パラメータ~およびポーズパラメータ~✓を変化させることによって生成され、アニメーション化されます。

SMPLモデルは最終的に次のように定義されます。

\[
M(~, ~✓; \Theta) = W\left( T_P(~, ~✓; \bar{T}, S, P), J(~; J, \bar{T}, S), ~✓, W \right) \tag{11}
\]

したがって、各頂点は次のように変換されます。

\[
t^0_i = \sum_{k=1}^{K} w_{k,i} G^0_k(~✓, J(~; J, \bar{T}, S)) t_{P,i}(~, ~✓; \bar{T}, S, P) \tag{12}
\]

ここで、\( t_{P,i}(~, ~✓; \bar{T}, S, P) \)は次のように表されます。

\[
t_{P,i}(~, ~✓; \bar{T}, S, P) = \bar{t}_i + \sum_{m=1}^{|~|} m s_{m,i} + \sum_{n=1}^{9K} (R_n(~✓) - R_n(~✓^*)) p_{n,i} \tag{13}
\]

この式では、\( \bar{t}_i \)はテンプレート頂点、\( s_{m,i} \)は形状ブレンドシェイプの要素、\( p_{n,i} \)はポーズブレンドシェイプの要素で、すべての要素が頂点iに適用された後の位置を表します。

以下では、LBS（線形ブレンドスキニング）とDQBS（デュアル四元数ブレンドスキニング）の両方を用いて実験を行い、それぞれのパラメータを学習します。これらのモデルをそれぞれSMPL-LBSおよびSMPL-DQBSと呼び、デフォルトモデルとしてSMPL-DQBSを使用します。また、SMPLという略語を使う場合、SMPL-DQBSを指します。





4 training
### SMPLモデルのパラメータ学習

SMPLモデルのパラメータを学習するために、2つのデータセットで再構成誤差を最小化することを目指します。各データセットは、私たちのテンプレートと同じトポロジーを持ち、高解像度3Dスキャンに基づいてアラインされたメッシュを含んでおり、これらを「登録（registrations）」と呼びます。

1. **マルチポーズデータセット**：
   - 40人の個人に対して1786の登録が含まれています（20人の女性に対して891件、20人の男性に対して895件）。
   - サンプリング例はFig. 4に示されています。

2. **マルチシェイプデータセット**：
   - CAESARデータセット [Robinette et al. 2002] に基づく登録が含まれており、男性用が1700件、女性用が2100件の合計登録が含まれています。
   - 数例はFig. 5に示されています。

各データセットのj番目のメッシュは、マルチポーズデータセットでは \( V_P^j \)、マルチシェイプデータセットでは \( V_S^j \) と表記します。

私たちの目標は、次のパラメータを学習することです：

\[
\Theta = \{ \bar{T}, W, S, J, P \}
\]

これらのパラメータの学習を通じて、データセット上の頂点再構成誤差を最小化します。私たちのモデルは形状とポーズを分解するため、これを別々に学習し、最適化を簡素化します。

- **最初の段階**では、マルチポーズデータセットを使用して \(\{ J, W, P \}\) を学習します。
- **次の段階**では、マルチシェイプデータセットを使用して \(\{ \bar{T}, S \}\) を学習します。

また、男性と女性のために別々のモデルを学習します（すなわち、mとf）。



4.1 pose parameter training
### SMPLモデルのパラメータ学習プロセス

私たちは、最初にマルチポーズデータセットを使用して \(\{ J, W, P \}\) を学習します。このために、各被験者 \(i\) のために、再構成テンプレート \(T^P_i\) と関節位置 \(J^P_i\) を計算し、データセット内の各登録 \(j\) に対するポーズパラメータ \(\tilde{\theta}_j\) を求めます。以下の手順を繰り返し、特定の登録におけるパラメータ \(\tilde{\theta}_j\)、被験者特有のパラメータ \(\{T^P_i, J^P_i\}\)、およびグローバルパラメータ \(\{W, P\}\) を最適化します。

最終的には、被験者特有の頂点位置 \(T^P_i\) から関節位置 \(J^P_i\) への回帰を行う行列 \(J\) を学習します。これを実現するために、データ項 \(E_D\) と以下に定義する複数の正則化項 \(\{E_J, E_Y, E_P, E_W\}\) から構成される目的関数を最小化します。

#### データ項
データ項は、登録された頂点とモデルの頂点との間のユークリッド距離の二乗をペナルティとして与えます。

\[
E_D(T^P, J^P, W, P, \Theta) = \sum_{j=1}^{P_{reg}} \left\| V_P^j - W\left(T^P_{s(j)} + B_P(\tilde{\theta}_j; P), J^P_{s(j)}, \tilde{\theta}_j, W\right)\right\|^2
\]

ここで、\(\Theta = \{\tilde{\theta}_1, \ldots, \tilde{\theta}_{P_{reg}}\}\) であり、\(s(j)\) は登録 \(j\) に対応する被験者のインデックス、\(P_{reg}\) はポーズトレーニングセット内のメッシュの数を表します。\(T^P = \{T^P_i\}_{i=1}^{P_{subj}}\) および \(J^P = \{J^P_i\}_{i=1}^{P_{subj}}\) は、それぞれ全ての再構成ポーズと関節の集合を示し、\(P_{subj}\) はポーズトレーニングセット内の被験者数です。

#### パラメータの推定
私たちは以下のパラメータを推定します：
- ポーズブレンドシェイプ \(P\)：\(207 \times 3 \times 6890 = 4,278,690\) パラメータ
- スキニングウェイト \(W\)：\(4 \times 3 \times 6890 = 82,680\) パラメータ
- 関節回帰行列 \(J\)：\(3 \times 6890 \times 23 \times 3 = 1,426,230\) パラメータ

#### 正則化項
推定を適切に行うために、いくつかの仮定を設けて正則化を行います。具体的には、対称性を考慮した正則化項 \(E_Y\) を導入し、左-右の非対称性をペナルティとして与えます。

\[
E_Y(J^P, T^P) = \sum_{i=1}^{P_{subj}} U \left( \|J^P_i - U(J^P_i)\|^2 + \|T^P_i - U(T^P_i)\|^2 \right)
\]

ここで、\(U = 100\) であり、\(U(T)\) は、脊柱面に沿って反転させ、対称的な頂点を入れ替えることで、頂点 \(T\) の鏡像を見つける関数です。この項は、対称的なテンプレートメッシュ、そして特に関節位置の対称性を促進します。関節は観測されない変数であり、脊柱に沿った位置の特定は特に難しいです。対称性項なしで学習したモデルは合理的な結果を生むものの、対称性を強制することで、アニメーションにおいて視覚的に直感的なモデルを生成します。

### モデルの初期推定と正則化

私たちのモデルは、24の部品に手動でセグメント化されています（図6参照）。このセグメンテーションを使用して、関節中心の初期推定値と、頂点からこれらの中心への回帰器 \(J_I\) を計算します。この回帰器は、2つの部品を接続する頂点のリングの平均を取ることによって初期の関節を計算します。各被験者の関節を推定する際には、これらを初期予測値に近づけるように正則化します。

#### 関節の正則化項
関節位置の推定に関する正則化項は次のように表されます。

\[
E_J(T^P, J^P) = \sum_{i=1}^{P_{subj}} \left\| J_I T^P_i - J^P_i \right\|^2
\]

ここで、\(T^P_i\) は被験者 \(i\) の再構成テンプレート、\(J^P_i\) は被験者の関節位置を示しています。

### ポーズ依存ブレンドシェイプの正則化
ポーズ依存ブレンドシェイプの過学習を防ぐために、以下のように正則化します。

\[
E_P(P) = \| P \|_F^2
\]

ここで、\(\| \cdot \|_F\) はフロベニウスノルムを示します。二次ペナルティをL1ペナルティに置き換えることでブレンドシェイプのスパース性を高めることができると考えられますが、私たちはこのアプローチを試みていません。

### スキニングウェイトの正則化
スキニングウェイトは初期の重み \(W_I\) に向かうように正則化されます。

\[
E_W(W) = \| W - W_I \|_F^2
\]

初期の重みは、単純にセグメンテーションを拡散させることによって計算されます。

### 全体的なエネルギー関数
したがって、パラメータ \(\{W, P\}\) の学習に関するエネルギーは次のようになります。

\[
E^*(T^P, J^P, \Theta, W, P) = E_D + Y E_Y + J E_J + P E_P + E_W
\]

ここで、\(Y = 100\)、\(J = 100\)、\(P = 25\) は経験的に設定された重みです。このモデルは多くのパラメータを持ち、正則化により過学習を防ぎます。トレーニングセットのサイズが大きくなるにつれて、データ項の影響が強まり、正則化項の影響は相対的に減少します。以下のテストデータを用いた実験では、学習したモデルがデータに対して過学習せず、よく一般化されていることを示しています。

### 関節回帰器
上記の最適化によって、各被験者に対してテンプレートメッシュと関節位置が得られますが、新しい被験者の新しい体型に対する関節位置を予測したいと考えています。この目的のために、トレーニングされた体型からトレーニングされた関節を予測するための回帰行列 \(J\) を学習します。

いくつかの回帰戦略を試しましたが、最も効果的だったのは、非負最小二乗法 [Lawson and Hanson 1995] を使用し、重みが1に加算されるような項を含めることでした。このアプローチは、関節を予測するために使用される頂点のスパース性を促進します。重みを正にし、合計が1になるようにすることで、表面外の関節を予測することを抑制します。これらの制約は、予測が表面点の凸包内に収まるように強制します。図7には、回帰行列の非ゼロ要素が示されており、スパースな表面頂点のセットが関節中心を推定するために線形に組み合わされています。



4.2 shape parameter training
### 形状空間の定義と主成分分析

私たちの形状空間は、平均形状 \( \bar{T} \) と主成分形状方向 \( \{T\} \) によって定義されます。この空間は、ポーズ正規化後のマルチシェイプデータベースからの形状登録に対して主成分分析（PCA）を実行することで計算されます。ポーズ正規化は、生の登録 \( V^S_j \) を、安静ポーズ \( \theta^* \) における登録 \( \hat{T}^S_j \) に変換します。この正規化は、ポーズと形状が別々にモデル化されることを保証するために重要です。

#### ポーズの推定
登録 \( V^S_j \) のポーズを推定するために、まず以下の平均形状と平均関節位置を定義します。

- \( \hat{T}^P_\mu \): マルチポーズデータベースからの平均形状
- \( \hat{J}^P_\mu \): マルチポーズデータベースからの平均関節位置

モデルのエッジを示す \( We(\hat{T}^P_\mu, \hat{J}^P_\mu, \theta, W) \) と、登録のエッジを示す \( V^S_{j,e} \) について、次の平方和の差を最小化します。

\[
\theta_j = \arg \min_{\theta} \sum_e \left\| We(\hat{T}^P_\mu + BP(\theta; P), \hat{J}^P_\mu, \theta, W) - V^S_{j,e} \right\|^2
\]

ここで、和はメッシュ内の全てのエッジにわたります。この方法により、対象の特定形状を知らなくてもポーズの良い推定が得られます。

#### 形状の正規化
ポーズ \( \theta_j \) が分かった後、次の式を最小化することで \( \hat{T}^S_j \) を解決します。

\[
\hat{T}^S_j = \arg \min_{T} \left\| W(T + BP(\theta_j; P), J_T, \theta_j, W) - V^S_j \right\|^2
\]

これは、ポーズされたときにトレーニング登録と一致する形状を計算します。この形状がポーズ正規化された形状です。

### 主成分分析と形状基底の構築
その後、\(\{ \hat{T}^S_j \}_{j=1}^{S_{subj}}\) に対してPCAを実行し、\(\{ \bar{T}, S \}\) を得ます。この手順は、限られた数の形状方向を考慮して、安静ポーズにおける頂点オフセットの説明分散を最大化するように設計されています。

#### ポーズの最適化の重要性
ポーズの最適化は、頂点から形状基底を構築する際に非常に重要です。このステップがないと、形状トレーニングデータセット内の対象のポーズの変動が、形状ブレンドシェイプに捉えられてしまいます。結果として得られるモデルは、形状とポーズに適切に分解されません。

#### SCAPEおよびBlendSCAPEとの対比
このアプローチは、各三角形変形の空間でPCAを行うSCAPEやBlendSCAPEとは対照的です。三角形の変形はユークリッド空間には存在しないため、頂点に対するPCAはより原理的であり、平方頂点差異から成る登録データ項と一貫性があります。

### 形状コンポーネントの可視化
図8では、最初の3つの形状コンポーネントが視覚化されています。この図は、体形の変化に伴う関節位置の変化も示しています。関節位置は球体で示され、学習した関節回帰関数を用いてサーフェスメッシュから計算されます。標準偏差を越えて関節を接続する線は、形状に対する関節位置の線形変動を示しています。

### SMPLとBlendSCAPEの累積分散の比較
図9は、SMPLとBlendSCAPEの相対的な累積分散を示しています。SMPLは、全体の分散の同じ割合を説明するために必要な主成分がはるかに少なくて済みますが、両者の分散は異なります：一方は頂点位置の分散であり、もう一方は三角形変形の分散です。変形における説明された分散は、頂点位置における説明された分散に直接変換されません。このため、二つのモデルの正確な比較は困難ですが、三角形変形はより多くの自由度を持っており、視覚的に類似した形状を生成する変形が多く存在する可能性があります。一般に、より少ないコンポーネントを必要とするモデルの方が望ましいです。



4.3 optimization summary
### ポーズパラメータの初期化とモデルの推定

ポーズパラメータ \( \tilde{\theta}_j \) は、モデルと登録エッジの差を最小化することによって初期化されます。このプロセスは、平均テンプレート形状を使用して Eq. (15) に類似しています。その後、以下のパラメータ \(\{ \hat{T}^P, \hat{J}^P, W, P, \Theta \}\) を交互に推定し、Eq. (14) を最小化します。

1. **パラメータの初期化**:
   - 平均テンプレート形状を基に、ポーズパラメータを初期化します。この初期化は、モデルのエッジと登録エッジ間の差を最小化することを目的としています。

2. **パラメータの交互推定**:
   - パラメータ \(\{ \hat{T}^P, \hat{J}^P, W, P \}\) を交互に推定して、最適化関数 Eq. (14) を最小化します。これにより、モデルは対象のメッシュデータに適合します。

3. **関節回帰行列の推定**:
   - \(\{ \hat{J}^P, \hat{T}^P \}\) から関節回帰行列 \( J \) を推定します。この行列は、各頂点位置から関節位置を予測するために使用されます。

4. **主成分分析 (PCA)**:
   - ポーズ正規化された対象 \(\{ \hat{T}^S_j \}_{j=1}^{S_{subj}}\) に対して PCA を実行し、形状基底 \(\{ \bar{T}, S \}\) を取得します。これにより、形状のバリエーションを捉えるための主成分が得られます。

### 最終モデルの定義

最終的なモデルは次のパラメータによって定義されます：

- \( J \): 関節回帰行列
- \( W \): スキンウェイト
- \( P \): ポーズ依存ブレンドシェイプ
- \( \bar{T} \): 平均形状
- \( S \): 主成分形状方向

### 最適化手法

すべてのトレーニングパラメータは、特に \(\{ \bar{T}, S \}\) を除いて、勾配に基づくドッグレッグ最適化（dogleg minimization）を用いて見つけられます。このプロセスでは、勾配は自動微分を用いて計算され、Chumpyフレームワーク（[Loper and Black 2014](https://www.cs.cmu.edu/~bmcl/Chumpy/)）が利用されます。これにより、モデルの収束が効率的に達成され、トレーニングが安定します。





5 smpl evaluation
この研究で使用されるすべてのトレーニング対象者は、統計モデル作成のためにデータを使用することに対して、事前に情報を得た上で書面による同意を与えています。また、ここに示されている登録メッシュおよび識別可能な被験者は、契約のもとで働いているプロのモデルです。

このように、データの使用に関する倫理的配慮と、参加者のプライバシーを守るための取り組みがなされていることが強調されています。



5.1 quantitative evaluation
私たちは、モデルの一般化とポーズの一般化の2種類のエラーを評価します。モデルの一般化は、新しい人々やポーズのメッシュに適合する能力を示し、これは形状およびポーズのブレンドシェイプの両方をテストします。一方、ポーズの一般化は、個々の形状を新しいポーズに一般化する能力を示し、これは主にポーズブレンドシェイプがスキニングのアーティファクトやポーズ依存の変形をどれだけ修正できるかをテストします。両者は、モデルとテスト登録間の平均絶対頂点間距離によって測定されます。

この評価には、公共のDynaデータセットから得た4人の女性と2人の男性の120の登録メッシュを使用します。これらのメッシュはさまざまな体型やポーズを含んでおり、すべてが私たちのテンプレートに整列しており、モデルのトレーニングには使用されていません。

私たちはSMPL-LBSとSMPL-DQBSを評価し、これらをSMPLモデルと同じデータから訓練されたBlendSCAPEモデルと比較します。SMPLとBlendSCAPEモデルの運動学的ツリー構造は同じであるため、ポーズパラメータの数も同じです。また、同じ数の形状パラメータを使用してモデルを比較します。

モデルの一般化を測定するために、まず各モデルを各登録メッシュにフィットさせ、形状\(\tilde{~}\)とポーズ\(\tilde{θ}\)を最適化して、二乗頂点距離の観点から最適なフィットを見つけます。図10には、登録メッシュへのSMPL-LBS（赤）とBlendSCAPE（青）モデルのフィットが示されています。どちらもデータに良くフィットしています。この図は、モデルの動作を示しており、推定された体型\(\bar{T} + BS(\tilde{~})\)とポーズブレンドシェイプの適用効果\(T_P(\tilde{~}, \tilde{θ})\)が示されています。

ポーズの一般化については、各個人に対して、一般化タスクから推定された体型の1つを選択し、その個人の他のメッシュのポーズ\(\tilde{θ}\)を最適化します。このとき、体型は固定されています。ポーズ一般化の背後にある仮定は、モデルがポーズと形状に適切に分解されていれば、異なるポーズで同じ被験者にフィットできるはずであるということです。ポーズブレンドシェイプは観察された登録にフィットするように訓練されているため、スキニングの問題を修正し、ポーズ依存の変形を捉えようとします。ポーズブレンドシェイプは体型に依存しないため、訓練セットの平均的な変形について何かをキャプチャします。

図11と図12には、使用された体型係数の数に対するSMPLモデルとBlendSCAPEのエラーが示されています。SMPLとBlendSCAPEの違いは小さく（約0.5mmのオーダー）、平均的にはSMPLの方がより正確です。驚くべきことに、SMPL-LBSとSMPL-DQBSはモデルの一般化において本質的に同一であり、SMPL-LBSは実際にはポーズの一般化においてわずかに優れています。これは、LBSの方が修正すべきことが多いポーズブレンドシェイプを持っているため、驚くべき結果です。おそらく、LBSのシンプルさが新しいポーズへの一般化に役立っているのでしょう。この分析は重要であり、ユーザーはDQBSモデルの代わりに、シンプルで迅速なLBSモデルを選択できることを示しています。

プロットは、標準のLBSがテストデータにどれだけフィットしているかも示しています。これはポーズブレンドシェイプがないSMPL-LBSモデルに対応しています。驚くべきことではありませんが、LBSはBlendSCAPEやSMPLよりもはるかに高いエラーを生成します。図11では、モデルが体型パラメータを変更できるため、変形を説明するためにアイデンティティの変化を効果的に利用します。図12は固定された体型を使用しており、その結果、LBSがポーズ依存の変形を現実的にモデル化できていない様子を示しています。ここでは、特にLBSのためにモデルを再トレーニングしていないため、再トレーニングしたモデルはわずかに正確であると予想されます。



5.2 sparse smmpl
SMPLにおけるポーズブレンドシェイプは、パートの回転がメッシュの任意の頂点に影響を与えるため、スパースではありません。十分なトレーニングデータがあれば、肩の修正が足首の動きに影響を受けないなど、データからスパース性が現れる可能性があります。手のアニメーションをより直感的にし、関節の長距離影響を防ぐために、スパース性を手動で強制することができます。この目的のために、ブレンドウェイトに使用されるのと同じスパース性パターンを使用してSMPLのスパースバージョンを訓練しました。具体的には、頂点の偏差が影響を受ける関節を最大4つまで許可します。各関節は回転行列に対応するため、特定の頂点に対応するポーズブレンドシェイプは、9×4の数値によって駆動され、通常の9×23よりも少なくなります。このモデルは、図11および図12でSMPL-LBS-Sparseと呼ばれています。

このモデルは、通常のSMPL-LBSモデルよりも常に精度が低いですが、アニメーターには依然として役立つ可能性があります。これは、SMPL-LBSがトレーニングデータに対して過剰適合していないことを示唆しており、スパース性がモデルの容量を削減することを意味します。スパースモデルは、異なる関節角度に影響を受ける頂点の境界でわずかな不連続性を生じることがあります。スパース性を強制するための他の戦略も採用できますが、たとえばL1プライオリティを使用したり、ポーズブレンドシェイプの滑らかさを強制したりすることが考えられます。ただし、これらのアプローチはトレーニングプロセスを複雑にする可能性があります。



5.3 visual evaluation
図13は、SMPLにおける形状パラメータ~とポーズパラメータ~✓の分解を示しています。左から右にかけて各行でポーズが一定に保たれ、形状が変化している一方で、各列でポーズが変化する間に各人の形状が一定に保たれています。これらの体は、CMUモーションキャプチャデータベース[CMU 2000]からのポーズを用いて再配置されています。非常に異なる体型にもかかわらず、ポーズ依存の変形が広範なポーズにわたって自然に見えることが分かります。これは、関節回帰がうまく機能しており、ブレンドシェイプが一般化されていることを示しています。

さらに多くの例やアニメーション、SMPLとBlendSCAPEの比較、ポーズブレンドシェイプ、体型およびポーズの変化を示す補足ビデオもご覧ください。



5.4 run time performance
SMPLの実行時コストは、スキニングとブレンドシェイプの乗算によって支配されています。多くのスキニング実装が存在しますが、私たちは最速のものを主張しているわけではありません。私たちのCPUベースの実装のパフォーマンスとBlendSCAPEとの比較は、図14に示されています。このプロットは、頂点を生成するために必要な時間を示しています。BlendSCAPEのレンダリングは複数のコアを使用しているのに対し、SMPLのレンダリングはそうではないため、BlendSCAPEのシステム時間が壁時計時間よりも高いことに注意してください。

ここでは、体型を変更するコストを示しています。ほとんどのアプリケーションでは、これは一度行われ、その後形状は固定されます。メッシュのアニメーションコストは、ポーズブレンドシェイプからのみ発生し、このコストは0の形状係数に相当します。頂点数が同じメッシュの場合、SCAPEは常に遅くなります。SMPLでは、各ブレンドシェイプはサイズが3Nで、各形状ごとにその数だけの乗算が必要です。SCAPEは三角形の変形を使用しており、三角形ごとに9要素あり、頂点の約2倍の三角形があります。これにより、基本的な乗算の観点からSMPLとSCAPEの間には約6倍の差が生じます。



5.5 compatibility with rendering engines
SMPLは標準的なスキニングに基づいているため、既存の3Dアニメーションソフトウェアと互換性があります。具体的には、特定の体型に対して、主観固有の静止ポーズテンプレートメッシュとスケルトン（推定された関節位置）を生成し、SMPLをリグ付きモデルとしてエクスポートします。これにより、AutodeskのFilmbox（FBX）ファイルフォーマットでのクロスプラットフォーム互換性が実現されます。モデルは一般的なリグ付きメッシュとして読み込まれ、標準の3Dアニメーションソフトウェアで通常通りアニメーション化できます。

ポーズブレンドウェイトは事前に計算され、モデルにベイクされ、アニメーションFBXファイルとしてエクスポートできます。この種のファイルはアニメーションパッケージに読み込むことができ、そのまま再生されます。私たちはMaya、Unity、BlenderでアニメーションFBXファイルをテストしました。

ポーズブレンドウェイトは、時刻tにおけるポーズ\(\theta_t\)を考慮して、リアルタイムで計算することも可能です。そのために、関節角度を受け取り、ポーズブレンドウェイトを計算するスクリプトを提供しています。Maya 2013、2014、2015でSMPLの読み込みとアニメーションをテストしました。アニメーターは、Mayaで一般的に使用される任意の従来のアニメーション手法を使ってモデルをアニメーション化できます。SMPLモデルにアニメーションを適用するためのブレンドシェイプ補正を行うPythonスクリプトも提供予定です。必要に応じて、Maya内でポーズブレンドシェイプの値を手動で表示および編集することもできます。

UnityでもSMPLをテストしました。SMPLではブレンドウェイトの範囲は-1から+1ですが、Unityでは0から1の範囲です。そのため、互換性を持たせるために、私たちはウェイトをスケーリングおよび再センタリングしています。ポーズブレンドシェイプ係数のランタイム計算用に、ユーザーがSMPLのメッシュゲームオブジェクトに添付できるC#スクリプトを提供します。

形状とポーズブレンドシェイプを持つSMPLモデルと評価メッシュは、研究目的で[http://smpl.is.tue.mpg.de](http://smpl.is.tue.mpg.de)で入手可能です。





6 dmpl dynamic smpl
SMPLモデルは、ポーズによる静的な軟部組織の変形を表現しますが、身体の動きや地面との衝撃力によって生じる動的な変形はモデル化していません。4D登録データに軟部組織の動的情報が含まれている場合、個別のテンプレート形状を持つSMPLモデルのポーズのみを最適化してフィッティングを行います。SMPLと観測メッシュの間の変位は、動的な軟部組織の動きを対応させることができます。この動的変形をモデル化するために、動的ブレンドシェイプと呼ばれる新しい一連の加法的ブレンドシェイプを導入します。これらの追加の変位は、ポーズではなく、身体や四肢の速度と加速度に相関しています。

時刻\(t\)における動的制御ベクトル\(\mathbf{t} = [\dot{\mathbf{\theta}}_t, \ddot{\mathbf{\theta}}_t, \mathbf{v}_t, \mathbf{a}_t, \mathbf{t}_1, \mathbf{t}_2]\)を考えます。このベクトルは、ポーズの速度と加速度\(\dot{\mathbf{\theta}}_t, \ddot{\mathbf{\theta}}_t \in \mathbb{R}^{|\mathbf{\theta}|}\)、ルート関節の速度と加速度\(\mathbf{v}_t, \mathbf{a}_t \in \mathbb{R}^3\)、および予測された動的係数の履歴を表す2つのベクトル\(\mathbf{t}_1, \mathbf{t}_2 \in \mathbb{R}^{|\mathbf{w}|}\)から構成されます。

第3節の線形形式を拡張し、静止ポーズで他のブレンドシェイプに動的ブレンドシェイプ関数\(B_D(\mathbf{t}, \mathbf{w})\)を単純に追加します。ゼロポーズの形状は次のように表されます：

\[
T_D(\mathbf{w}, \mathbf{\theta}_t, \mathbf{t}) = \bar{T} + BS(\mathbf{w}) + BP(\mathbf{\theta}_t) + B_D(\mathbf{t}, \mathbf{w}),
\]

ここで、\(B_D(\mathbf{t}, \mathbf{w})\)は、時刻\(t\)の動的制御ベクトルと形状係数\(\mathbf{w}\)を入力として、静止ポーズでの頂点オフセットを予測します。

[Pons-Moll et al. 2015]では、動的変形は三角形変形を用いてモデル化されていましたが、DMPLでは頂点空間での変形をモデル化します。男性と女性のモデルは、[Dyn 2015]から約40,000の登録済み男性および女性メッシュを使用して構築します。各フレームでポーズを計算し、SMPLと登録との間の変位を求めます。PCAを用いて、平均値と動的ブレンドシェイプを取得します：

\[
\mu_D \in \mathbb{R}^{3N}, \quad D \in \mathbb{R}^{3N \times |\mathbf{w}|}.
\]

ここで、|\mathbf{w}| = 300の主成分を使用します。動的変形は、被験者の体型や脂肪分布に基づいて大きく変動します。これをキャプチャするために、Dynaと同様に体型パラメータ\(\mathbf{w}\)に依存するモデルを訓練します。

動的ブレンドシェイプは次のように予測されます：

\[
B_D(\mathbf{t}, \mathbf{w}; D) = \mu_D + D f(\mathbf{t}, \mathbf{w}),
\]

これは、[Pons-Moll et al. 2015]の式(22)に類似しており、\(f(\cdot)\)は動的制御ベクトル\(\mathbf{t}\)を入力として動的形状係数のベクトルを予測する関数です。このように、動的ブレンドシェイプに基づく軟部組織の変位の定式化は、Dynaとは異なり、私たちのモデルは現在のグラフィックスソフトウェアと互換性を保つことができます。モデルをアニメーション化するには、ポーズシーケンスと体型から係数\(\mathbf{t} = f(\mathbf{t}, \mathbf{w})\)を計算するスクリプトが必要です。

DMPLモデルは、Dynaよりもリアルな軟部組織の動態を生成することが観察されています。トレーニングデータ、動的ブレンドシェイプ、および得られたアニメーションの視覚化については、補足ビデオを参照してください。





7 disucussion
**なぜSMPLが機能するのか**  
まず、高品質のトレーニングデータが重要です。ここでは、数千の高品質な登録済みテンプレートメッシュを使用しています。特に、ポーズのトレーニングデータはさまざまな体型をカバーしており、関節位置の良好な予測器を学習することができます。次に、全てのパラメータ（テンプレート形状、ブレンドウェイト、関節回帰器、形状/ポーズ/動的ブレンドシェイプ）を頂点再構成誤差を最小化するようにトレーニングすることが、良いモデルを得るために重要です。ここでは、モデルのシンプルさが利点となり、大量のデータで全ての要素をトレーニングすることが可能です。

散発的データ補間法とは対照的に、私たちは可能なポーズの空間をカバーする大規模なトレーニングメッシュセットからブレンドシェイプを学習し、ポーズとブレンドシェイプウェイトとの関係を示す単純な関数を学習します。特に、私たちの関数は部位の回転行列の要素に関して線形です。学習した線形関数の広範なサポートは、放射基底関数に対してモデルが任意のポーズに一般化できることを可能にし、単純な線形形式は、ウェイトを焼き付けずにゲームエンジンでのアニメーションを迅速に行えるようにします。回転行列の要素が制約されているため、モデルはトレーニングセットの外で一般化する際に「暴走」することはありません。

**SMPLの加法モデルの特徴**  
SMPLは頂点空間での加法モデルです。一方で、SCAPEも変形を形状とポーズの変形に分解しますが、SCAPEは三角形の変形を乗算します。SCAPEでは、より大きな人物がより大きなポーズ依存の変形を持ちますが、これらの変形は異なる体型のために学習されていません。それにもかかわらず、私たちの実験では、SCAPEアプローチは新しい形状に一般化する際に精度が低くなっています。理想的には、異なる人々から十分なポーズデータがあれば、真の体型依存のポーズ変形空間を学習することが可能です。私たちのDMPLとの取り組みは、変形が体型に依存することを示唆しています。

**BlendSCAPEとの精度の違い**  
BlendSCAPEよりもなぜ精度が高いのか？三角形の変形の統計に基づくモデルが最近の文献で支配的です。これらのモデルは、トレーニング登録を直接再現するようには訓練されていません。その代わりに、それらの登録を生成した局所的な変形を再現するように訓練されています。これらのモデルの訓練の取り扱いやすさは、三角形ごとに独立して変形をトレーニングできることから来ています。その結果、長距離の距離や関係は、頂点間の局所的な関係ほど保存されません。私たちは、SMPLのような頂点ベースのモデル（および[Allen et al. 2006]）の利点は、モデルとトレーニング頂点間の平均二乗誤差を最小化するように訓練できることだと推測しています。理論的には、SCAPEモデルをグローバル座標系での頂点誤差を最小化するように訓練することも可能ですが、最適化の内部ループは、変形から頂点を再構築するための最小二乗問題を解くことを含むため、最適化のコストが大幅に増加し、大量のデータでモデルを訓練することが困難になります。

**なぜこれまで行われてこなかったのか**  
SMPLモデルはブレンドスキニングを拡張する自然な方法だと考えていますが、以前に発表されたバージョンはありません。残念ながら、明白な実装ではポーズブレンドシェイプが\(\tilde{\theta}\)の線形関数となりますが、これはうまく機能しません。SMPLの性能の鍵は、ブレンドシェイプを\(R^*(\tilde{\theta})\)の要素の線形関数として定義することです。この定式化、十分なトレーニングデータ、および良好な最適化戦略が、モデルを学習する可能性を与えます。

**最も近い研究**  
私たちの研究に最も近いのは、Allen et al. [2006]の先駆的な研究です。彼らのモデルは、散発的データ補間のための放射基底関数、形状依存のポーズ変形、固定されたキャリー角のセットを使用するなど、私たちのモデルよりも複雑です。したがって、訓練も複雑で、良好な初期化が必要です。彼らは限られたデータしか持っておらず、過学習に苦しんだため、体型のPCA空間を制限しました。その結果、モデルは新しい形状やポーズに対して十分に一般化しませんでした。私たちのシンプルなモデルは、大規模なデータセットから学ぶことを可能にし、より多くのデータがあることでシンプルなモデルがうまく機能します。

**ポーズブレンドシェイプを駆動する他の特徴**  
私たちは、ポーズブレンドシェイプを他の特徴（生の\(\tilde{\theta}\)、\(\tilde{\theta}\)の単純な多項式、\(\tilde{\theta}\)の三角関数（sin、cos）など）から線形に駆動する実験を行いましたが、これらは私たちの提案した定式化ほど良好な性能を発揮しませんでした。生の\(\tilde{\theta}\)を使用することには深刻な制限があります。なぜなら、値は\(-\pi\)から\(\pi\)の間で変動するからです。首をひねることを考えてみましょう（図16）。これは、垂直軸に沿って負の角度と正の角度を生成します。標準のLBSでは、首がどちらの方向にも回転する際に縮むことになります。この対策として、首がどの方向に回転しても体積が増加するブレンドシェイプが必要です。残念ながら、ブレンドシェイプが右回転中に膨張するように学習されると、左回転中には収縮してしまいます。

一般的に、原始的な回転を回転の任意の関数で置き換え、これらを使用してブレンドシェイプの重み付けを行うことができます。徹底的な検索は不可能で、他の特徴が私たちの方法と同様に機能する可能性があります。たとえば、正規化されたクォータニオンを使った実験は行いませんでした。

**散発的データ補間法との違い**  
私たちのポーズブレンドシェイプ関数は、WPSD [Kurihara and Miyata 2004; Rhee et al. 2006]のような散発的データ補間法とは非常に異なります。これらは離散的なポーズの数とそれに関連する補正を使用し、それらの間をRBFを用いて補間します。実際には、ポーズ空間をうまくカバーするには多くのポーズが必要です。これは、アニメーションを遅くし、実行時に最も近いキーポーズを見つける必要があるためです。

**制限事項**  
SMPLのポーズ依存のオフセットは体型に依存していません。これがうまく機能することは驚くべきことですが、体の部分のスケールが大きく異なる非現実的なアニメキャラクターの空間や、乳児と成人を含む人間の空間をモデル化する場合には、この一般的なアプローチはうまくいかないでしょう。

この制限は、\(\mathbf{R^*(\tilde{\theta})}\)の要素と\(\mathbf{~}\)を組み合わせてブレンドシェイプ係数を予測するより一般的な関数を学習することで対処できます。動的ブレンドシェイプ係数は体型に依存しているため、ポーズブレンドシェイプにも同様のことが可能であるはずです。これはモデルや実行時の挙動を大幅に複雑にすることはなく、追加のトレーニングデータが必要になるかもしれません。

現在のところ、SMPLモデルは関節角度と形状パラメータの関数だけであり、呼吸、顔の動き、筋肉の緊張、または骨格関節角度や全体の形状に依存しない変化をモデル化していません。これらは、適切な因子データが利用可能であれば（[Tsoli et al. 2014]を参照）、DMPLのように追加の加法的ブレンドシェイプとして学習することが可能です。

私たちはほとんどのモデルパラメータを学習しますが、すべてを学習するわけではありません。テンプレートの部分へのセグメンテーション、メッシュのトポロジー、ゼロポーズは手動で定義しています。理論的にはこれらも学習可能ですが、重要な労力に対してわずかな改善しか期待できません。

**今後の研究**  
SMPLは207のポーズブレンドシェイプを使用していますが、ブレンドシェイプに対してPCAを実行することで、これを削減できる可能性があります。これにより乗算の数が減少し、結果的にレンダリング速度が向上します。また、私たちの動的モデルは動的ブレンドシェイプを学習するためにPCAを使用していますが、ポーズブレンドシェイプと同様に、これらのブレンドシェイプの要素を直接学習することも可能です。最後に、ここでは登録されたメッシュにモデルをフィットさせましたが、モーションキャプチャマーカーのデータ（[Loper et al. 2014]を参照）、深度データ、またはビデオに対してSMPLをフィットさせることができます。SMPL-LBSモデルのポーズと形状を最適化することは、同等の品質のSCAPEモデルを最適化するよりも大幅に速くなると予想しています。





8 conclusions
私たちの目標は、既存のグラフィックスパイプラインやソフトウェアと互換性がありながら、最高の以前のモデルと同等またはそれ以上の、体の形状やポーズの変化をキャプチャできる骨格駆動型の人間のボディモデルを作成することでした。そのために、SMPLは標準的なスキニング方程式を使用し、基本メッシュを修正する体形状およびポーズブレンドシェイプを定義しています。私たちは、異なる人々の異なるポーズでの何千もの整列スキャンを用いてモデルをトレーニングしました。このモデルの形式により、大量のデータからパラメータを学習し、頂点再構成誤差を直接最小化することが可能です。具体的には、RESTテンプレート、ジョイントレグレッサー、体型モデル、ポーズブレンドシェイプ、および動的ブレンドシェイプを学習します。

驚くべき結果は、BlendSCAPEとSMPLがまったく同じデータでトレーニングされた場合、頂点ベースのモデルが変形ベースのモデルよりも正確で、レンダリングの効率が大幅に向上することです。また、比較的少ない数の学習されたブレンドシェイプがLBSの誤差を修正するのと同様に、DQBSにも効果的であることも驚きです。4D登録メッシュを使用して、SMPLを拡張し、ポーズに応じた動的ソフトティッシュ変形を自己回帰モデルとしてモデル化しました。SMPLはFBXファイルとしてエクスポートでき、一般的なレンダリングシステムでモデルをアニメーション化するためのスクリプトも提供しています。これにより、誰でも現実的に人間の体をアニメーション化できるようになります。